[/
          Copyright Oliver Kowalke 2009.
 Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt
]

[section:stack Stack]

A __context__ is required to maintain a stack and expects a rvalue reference of
a stack in its constructor.
The stack will be stored (moved) and managed inside __context__. With the destruction
of the __context__ instance the stack will be destroyed too or if desired the stack
might be released from the __context__ instance so that it can be reused.

A stack has to implement following implicit interface:

    class stack
    {
    public:
        stack();

        stack( stack && other);

        stack & operator=( stack && other);

        void * address() const;

        std::size_t size() const;

        void swap( stack & other);

        bool operator!() const;

        operator unspecified_bool_type() const;
    };

    void swap( stack & l, stack & r);


[heading `stack()`]
[variablelist
[[Effects:] [Creates an instance that refers to __not_a_stack__.]]
[[Postconditions:] [`operator unspecified-bool-type() const` returns `false`.]]
]

[heading `stack( std::size_t stacksize)`]
[variablelist
[[Effects:] [Allocates memory used for the stack.]]
[[Postconditions:] [`operator unspecified-bool-type() const` returns `true`.]]
]

[heading `stack( stack && other)`]
[variablelist
[[Effects:] [Moves the managed memory of `other` to `*this`.
`other` becomes __not_a_stack__.]]
]

[heading `stack & operator=( stack && other)`]
[variablelist
[[Effects:] [Destoyes the stack and internal data of `*this` and moves the
managed memory of `other` to `*this`. `other` becomes __not_a_stack__.]]
]

[heading `void * address() const`]
[variablelist
[[Effects:] [Retuns the highest address of the stack where `*this`
beginns to grow downwards.]]
]

[heading `std::size_t size() const`]
[variablelist
[[Effects:] [Retuns the size of the stack.]]
]

[heading `void swap( stack & other)`]
[variablelist
[[Effects:] [Swaps the managed memory and stacksize with the values
store in `other`.]]
]

[heading `operator unspecified-bool-type() const`]
[variablelist
[[Returns:] [If `*this` refers to a stack, the function returns true. Otherwise
false.]]
]

[heading `bool operator!() const`]
[variablelist
[[Returns:] [If `*this` refers not to a stack, the function returns true.
Otherwise false.]]
]

[heading Non-member function `swap()`]

    void swap( stack & l, stack & r);

[variablelist
[[Effects:] [Swaps content of `l` with `r`.]]
]

[important The stack implementation should protect for exceeding the stacksize!
If the stack grows over its bounds it would generate in best case a segmentation
fault/access violation (addresses do not belong to the application) otherwise
the memory of the application will be overwritten resulting in unexpected
behaviour.]


[section:protected_stack Class `protected stack`]

__boost_context__ provides an __protected_stack__ - which appends a
__guard_page__ to protect against exceeding the stack. If the guard page
is accessed (read or write operation) a segmentation fault/access violation is
generated by the operating system.

    class protected_stack
    {
    public:
        protected_stack();

        explicit protected_stack( std::size_t);

        ~protected_stack();

        protected_stack( protected_stack && other);

        protected_stack & operator=( protected_stack && other);

        void * address() const;

        std::size_t size() const;

        void swap( protected_stack & other);

        bool operator!() const;

        operator unspecified-bool-type() const;
    };

    void swap( protected_stack & l, protected_stack & r);


[heading `protected_stack()`]
[variablelist
[[Effects:] [Creates an instance that refers to __not_a_stack__.]]
[[Throws:] [Nothing.]]
[[Postconditions:] [`operator unspecified-bool-type() const` returns `false`.]]
]

[heading `protected_stack( std::size_t stacksize)`]
[variablelist
[[Effects:] [Allocates memory used for the stack. At the end of the stack a
`guard-page` is appended.]]
[[Postconditions:] [`*this` refers to the newly created stack.]]
[[Throws:] [__bad_alloc__ and __invalid_argument__ if `stacksize` is smaller
than the minimal stacksize or larger than the maximal stacksize defined by
the environment.]]
[[Postconditions:] [`operator unspecified-bool-type() const` returns `true`.]]
]

[heading `~protected_stack()`]
[variablelist
[[Effects:] [Deallocates memory of the stack.]]
[[Throws:] [Nothing.]]
]

[heading `protected_stack( protected_stack && other)`]
[variablelist
[[Effects:] [Moves the managed memory of `other` to `*this`.
`other` becomes __not_a_stack__.]]
[[Throws:] [Nothing.]]
]

[heading `protected_stack & operator=( protected_stack && other)`]
[variablelist
[[Effects:] [Destroyes the stack and internal data of `*this` and moves the
managed memory of `other` to `*this`. `other` becomes __not_a_stack__.]]
[[Throws:] [Nothing.]]
]

[heading `void * address() const`]
[variablelist
[[Effects:] [Retuns the highest address of the stack where `*this`
beginns to grow downwards.]]
[[Throws:] [Nothing.]]
]

[heading `std::size_t size() const`]
[variablelist
[[Effects:] [Retuns the size of the stack.]]
[[Throws:] [Nothing.]]
]

[heading `void swap( protected_stack & other)`]
[variablelist
[[Effects:] [Swaps the managed memory and stacksize with the values
store in `other`.]]
[[Throws:] [Nothing.]]
]

[heading `operator unspecified-bool-type() const`]
[variablelist
[[Returns:] [If `*this` refers to __not_a_stack__, the function returns false. Otherwise
true.]]
[[Throws:] [Nothing.]]
]

[heading `bool operator!() const`]
[variablelist
[[Returns:] [If `*this` refers not to __not_a_stack__, the function returns true.
Otherwise false.]]
[[Throws:] [Nothing.]]
]

[heading Non-member function `swap()`]

    #include <boost/context/protected_stack.hpp>

    void swap( protected_stack & l, protected_stack & r);

[variablelist
[[Effects:] [Swaps content of `l` with `r`.]]
[[Throws:] [Nothing.]]
]

[endsect]


[section:stack_helper Class `stack_helper`]

__stack_helper__ provides an easy access to the stack related limits defined by
the environment.

    struct stack_helper
    {
        static std::size_t default_stacksize();

        static std::size_t pagesize();

        static std::size_t page_count( std::size_t stacksize);

        static bool unlimited_stacksize();

        static std::size_t minimal_stacksize();

        static std::size_t maximal_stacksize();
    };

[heading `static std::size_t default_stacksize()`]
[variablelist
[[Returns:] [Defines a default stack size of 256 kB.]]
]

[heading `static std::size_t pagesize()`]
[variablelist
[[Returns:] [Returns how many bytes the operating system allocates for one page.]]
[[Throws:] [Nothing.]]
]

[heading `static std::size_t page_count( std::size_t stacksize)`]
[variablelist
[[Returns:] [Returns how many pages have to be allocated for a stack of `stacksize` bytes.]]
[[Throws:] [Nothing.]]
]

[heading `static bool unlimited_stacksize()`]
[variablelist
[[Returns:] [Returns `true` if the environment defines no limit for the size of a stack.]]
[[Throws:] [Nothing.]]
]

[heading `static std::size_t minimal_stacksize()`]
[variablelist
[[Returns:] [Returns the minimal size in bytes of stack defined by the environment.]]
[[Throws:] [Nothing.]]
]

[heading `static std::size_t maximal_stacksize()`]
[variablelist
[[Preconditions:] [`bool unlimited_stacksize()` returns `false`.]]
[[Returns:] [Returns the maximal size in bytes of stack defined by the environment.]]
[[Throws:] [Nothing.]]
]

[heading Non-member function `swap()`]

    void swap( protected_stack & l, protected_stack & r);

[variablelist
[[Effects:] [Swaps content of `l` with `r`.]]
]

[endsect]

[endsect]
