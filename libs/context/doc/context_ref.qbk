[/
          Copyright Oliver Kowalke 2009.
 Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt
]

[section:context Context]

[heading Synopsis]

Each instance of __context__ represents a context (CPU registers and stack
space) of execution or __not_a_context__. Objects of type __context__ are
moveable but not copyable and can be returned by a function.

        boost::contexts::context make_context();

        void f()
        {
                boost::contexts::context ctx( make_context() );
                ctx.resume();
        }

[note In order to implement rvalue references __boost_move__ is used.]

[warning If contexts are migrated between threads the code called by a context
must not use __tls__.]

[note If __fls__ is used on Windows the user is responsible to call
__fls_alloc__, __fls_free__.]


[heading Executing context]

A new context is created from a callable object (known as the
__context_fn__), the stack size and two arguments determine stack unwinding and
context termination.

Each __context__ is associated with a stack which will be allocated and
deallocated by a stack_link[__stack_allocator_concept__]. __context__ uses
stack_link[__stack_allocator__] per default - it is possible to specify an
alternative allocator by passing it to the constructor.
The stack will be allocated in the __context__ constructor and deallocated in
the destructor of __context__.

If desired a function or callable object that requires arguments can be supplied
by passing additional arguments to the __context__ constructor.

    void f( int i);

    boost::contexts::context ctx = boost::contexts::context( f, 42,
		boost::contexts::default_stacksize(),
		boost::contexts::no_stack_unwind, boost::contexts::return_to_caller);

The arguments are copied into the internal context structure: if a reference is
required, use boost::ref, just as for references to callable functions.

The maximum number of arguments of __context_fn__ is defined by
BOOST_CONTEXT_ARITY (default is 10) and might be changed.

Starting the context requires to call __context_start__ first and only once.
The execution control is transfered to the newly created __context__, as an
invocation of the __context_fn__; registers, flags, stack and instruction
pointer are saved to be recovered later. When control needs to be transfered to
the original calling context, __context_suspend__ should be called; the current
context (registers, flags, stack and instruction pointer) is saved, while the
calling context is restored.
The next time __context_resume__ is called the execution control is transfered
back to the context by returning from __context_suspend__.

        boost::contexts::context ctx;

        void fn( int j)
        {
            for( int i = 0; i < j; ++i)
            {
                std::cout << "fn(): local variable i == " << i << std::endl;

                // save current context
                // value of local variable is preserved
                // transfer execution control back to caller
                ctx.suspend();

                // ctx.resume() was called
                // execution control transfered back to fn()    
            }
        }

        int main( int argc, char * argv[])
        {
            ctx = boost::contexts::context( fn, 7,
				boost::contexts::default_stacksize(),
				boost::contexts::no_stack_unwind,
				boost::contexts::return_to_caller);

            std::cout << "main() calls context ctx" << std::endl;
			// start the context ctx for the first time
			// enter fn()
			ctx.start();

			// ctx.suspend() was called so we returned from start()
            while ( ! ctx.is_complete() )
            {
                std::cout << "main() calls context ctx" << std::endl;
                // resume inside fn()
                // execution control is transfered to ctx
                ctx.resume();

                // ctx.suspend() was called
            }

            std::cout << "Done" << std::endl;

            return EXIT_SUCCESS;
        }

[warning Calling __context_resume__ from inside the same context undefined
behaviour will happen.]

[note In contrast to threads, which are preemtive, __context__ switches are
cooperative (programmer controls when switch will happen). The kernel does never
'see' the context switches.]


[heading Transfer of data]

__boost_context__ allows to transfer data between contexts. __context_resume__
and __context_suspend__ accept a void pointer as argument and return a void
pointer.
The void pointer passed as argument to on of both functions is returned by its
counterpart function. That means: the void pointer passed to __context_resume__
is returned by __context_suspend__ which was called in the other context (to
which __context_resume__ transfers the execution cotnrol back).
__context_suspend__ does the same, the void pointer arg is returned by
__context_resume__ and __context_start__, depending on which function was called
before.
__context_start__ has no void pointer argument because of it enters the context
thus there is not return to __context_suspend__. 

        boost::contexts::context ctx;

        void fn()
        {
			  int i = 7;
              std::cout << "fn(): local variable i == " << i << std::endl;

              // save current context
              // transfer execution control back to caller
			  // pass pointer to local variable i
              void * vp = ctx.suspend( & i);
			  int j = * static_cast< int * >( vp);

              std::cout << "transfered value: " << j << std::endl;
        }

        int main( int argc, char * argv[])
        {
            ctx = boost::contexts::context( fn,
				boost::contexts::default_stacksize(),
				boost::contexts::no_stack_unwind,
				boost::contexts::return_to_caller);

            std::cout << "main() calls context ctx" << std::endl;

			// start the context ctx for the first time
			// enter fn()
			void * vp = ctx.start();
			int x = * static_cast< int * >( vp);

            std::cout << "transfered value: " << x << std::endl;
			x = 10;

			// ctx.suspend() was called so we returned from start()
            ctx.resume( & x);

            std::cout << "Done" << std::endl;

            return EXIT_SUCCESS;
        }


[heading Exceptions in context function]

If the __context_fn__ passed to __context__ constructor propagates an exception,
std::terminate() is called.

[important The code executed by __context__ may not use catch ellipses and
swallow the exception used for unwinding the stack otherwise stack unwinding
doesn't work.]


[heading Terminating context]

The last argument `do_return` in the constructor of __context__ takes a bool
value which determines what happens after the context is complete
(== __context_fn__ returns). A value of `true` transfers the execution control
back to the last invokation of __context__resume__.

        boost::contexts::context ctx;

        void fn( int j)
        {
            for( int i = 0; i < j; ++i)
            {
                std::cout << "fn(): local variable i == " << i << std::endl;
                ctx.suspend();
            }

            // fn() returns
            // execution control is transfered back to main()
        }

        int main( int argc, char * argv[])
        {
            ctx = boost::contexts::context( fn, 7,
				boost::contexts::default_stacksize(),
				boost::contexts::no_stack_unwind,
				boost::contexts::no_return_to_caller);

			ctx.start();
            while ( ! ctx.is_complete() )
            {
                std::cout << "main() calls context ctx" << std::endl;
                ctx.resume();
            }

            // fn() returned; the context is complete

            std::cout << "Done" << std::endl;

            return EXIT_SUCCESS;
        }

A value of `false` inidcates that the application terminates (exit-code == 0)
after the context becomes complete.

        boost::contexts::context ctx;

        void fn( int j)
        {
            for( int i = 0; i < j; ++i)
            {
                std::cout << "fn(): local variable i == " << i << std::endl;
                ctx.suspend();
            }

            // fn() returns
            // application will terminate
        }

        int main( int argc, char * argv[])
        {
            ctx = boost::contexts::context( fn, 7,
				boost::contexts::default_stacksize(),
				boost::contexts::no_stack_unwind,
				boost::contexts::no_return_to_caller);

			ctx.start();
            while ( ! ctx.is_complete() )
            {
                std::cout << "main() calls context ctx" << std::endl;
                ctx.resume();
            }

            // never reached
            std::cout << "Done" << std::endl;

            return EXIT_SUCCESS;
        }


[heading Linking context]

__boost_context__ provides the ability to link __context__ instances. In the
constructor of __context__ the last argument is a reference to a context (which
must not be a __not_a_context__). If a context becomes complete and a successor
was defined then the __context_fn__ of the successor will be invoked.
It is possible to create a chain of contexts and depending on the `do_return`
argument in the constructor of the last context in the chain the application
terminates or the execution control is transfered back to the last invokation of
__context_resume__. Each call of __context_suspend__ for the chained context
instances will return to __context_resume__.

        boost::contexts::context ctx2;

        void fn1()
        {
            std::cout << "fn1(): when fn1() returns fn2() will be entered" << std::endl;
        }

        void fn2()
        {
            std::cout << "first time inside fn2()" << std::endl;
            ctx2.suspend();
            std::cout << "second time inside fn2(), returns to main()" << std::endl;
        }

        int main( int argc, char * argv[])
        {
            {
                // ctx2 will return to ctx2.resume()
                ctx2 = boost::contexts::context(
                    fn2, 
                    boost::contexts::default_stacksize(),
					boost::contexts::no_stack_unwind,
					boost::contexts::return_to_caller);

                // ctx1 defines ctx2 as its successor
                boost::contexts::context ctx1(
                    fn1, 
                    boost::contexts::default_stacksize(),
					boost::contexts::no_stack_unwind, ctx2);

                // transfer execution control to ctx1
                // fn1() is entered 
                ctx1.start();

                // ctx2.suspend() was called
            }

			// ctx2 was already started by ctx1 
            ctx2.resume();

            std::cout << "Done" << std::endl;

            return EXIT_SUCCESS;
        }

[important __context_start__ must not be called on a linked context.]


[heading Unwinding stack]

Sometimes it is necessary to unwind the stack of an unfinished context because
of local variables on the stack which allocated resourcesi (RAII pattern).
The next to last argumenti `do_unwind` of contexts constructor deterimes if the
stack should be automaticaly unwound in the destructor of the context or not.
The unwinding of the stack can be triggered by __context_unwind__ too.
Preconditions for stack unwinding are the the instance of context is not a
__not_a_context__, the context is not complete, does own a stack and is not
running.
After unwinding the context is complete (postcondition).

        boost::contexts::context ctx;

        struct X
        {
            X()
            { std::cout << "X()" << std::endl; }

            ~X()
            { std::cout << "~X()" << std::endl; }
        };

        void fn()
        {
            X x;

            for( int i = 0;; ++i)
            {
                std::cout << "fn(): " << i << std::endl;
                // transfer execution control back to main()
                ctx.suspend();
            }
        }

        int main( int argc, char * argv[])
        {
            ctx = boost::contexts::context(
                    fn,
                    boost::contexts::default_stacksize(),
					boost::contexts::no_stack_unwind,
					boost::contexts::return_to_caller);
			ctx.start();
            for ( int i = 0; i < 5; ++i)
            {
                // transfer execution control to fn()
                ctx.resume();
            }

            std::cout << "ctx is complete: " << std::boolalpha << ctx.is_complete() << "\n";
            std::cout << "call ctx.unwind_stack()" << std::endl;

            // unwind the stack
            // X::~X() will be called
            ctx.unwind_stack(); // unwind the stack

            std::cout << "ctx is complete: " << std::boolalpha << ctx.is_complete() << "\n";
            std::cout << "Done" << std::endl;

            return EXIT_SUCCESS;
        }


[section:context Class `context`]

    #include <boost/context/context.hpp>

    class context
    {
    public:
        context();

        template< typename Fn >
        context( Fn fn, std::size_t size, flag_unwind_t do_unwind, flag_return_t do_return);

        template< typename Fn, typename Allocator >
        context( Fn fn, std::size_t size, flag_unwind_t do_unwind, flag_return_t do_return, Allocator const& alloc);

        template< typename Fn >
        context( Fn fn, std::size_t size, flag_unwind_t do_unwind, context & nxt);

        template< typename Fn, typename Allocator >
        context( Fn fn, std::size_t size, flag_unwind_t do_unwind, context & nxt, Allocator const& alloc);

        template< typename Fn, typename A0 >
        context( Fn fn A0 a0, std::size_t size, flag_unwind_t do_unwind, flag_return_t do_return);
        ...
        template< typename Fn, typename A0,.., typename A9 >
        context( Fn fn A0 a0, A9, a9, std::size_t size, flag_unwind_t do_unwind, flag_return_t do_return);

        template< typename Fn, typename Allocator, typename A0 >
        context( Fn fn A0 a0, std::size_t size, flag_unwind_t do_unwind, flag_return_t do_return, Allocator const& alloc);
        ...
        template< typename Fn, typename Allocator, typename A0,.., typename A9 >
        context( Fn fn A0 a0, A9, a9, std::size_t size, flag_unwind_t do_unwind, flag_return_t do_return, Allocator const& alloc);

        template< typename Fn, typename A0 >
        context( Fn fn A0 a0, std::size_t size, flag_unwind_t do_unwind, context & nxt);
        ...
        template< typename Fn, typename A0,.., typename A9 >
        context( Fn fn A0 a0, A9, a9, std::size_t size, flag_unwind_t do_unwind, context & nxt);

        template< typename Fn, typename Allocator, typename A0 >
        context( Fn fn A0 a0, std::size_t size, flag_unwind_t do_unwind, context & nxt, Allocator const& alloc);
        ...
        template< typename Fn, typename Allocator, typename A0,.., typename A9 >
        context( Fn fn A0 a0, A9, a9, std::size_t size, flag_unwind_t do_unwind, context & nxt, Allocator const& alloc);

        template< typename Fn >
        context( Fn && fn, std::size_t size, flag_unwind_t do_unwind, flag_return_t do_return);

        template< typename Fn, typename Allocator >
        context( Fn && fn, std::size_t size, flag_unwind_t do_unwind, flag_return_t do_return, Allocator const& alloc);

        template< typename Fn >
        context( Fn && fn, std::size_t size, flag_unwind_t do_unwind, context & nxt);

        template< typename Fn, typename Allocator >
        context( Fn && fn, std::size_t size, flag_unwind_t do_unwind, context & nxt, Allocator const& alloc);

        ~context();

        context( context && other);

        context & operator=( context && other);

        operator unspecified-bool-type() const;

        bool operator!() const;

        void swap( context & other);

        bool is_complete() const;

        bool is_running() const;

        void * start();

        void * resume( void * vp = 0);

        void * suspend( void * vp = 0);

        void unwind_stack();
    };

    void swap( context & l, context & r);

[heading `context()`]
[variablelist
[[Effects:] [Creates an context representing a __not_a_context__.]]
[[Throws:] [Nothing.]]
]

[heading `template< typename Fn > context( Fn fn, std::size_t size, flag_unwind_t do_unwind, flag_return_t do_return)`]
[variablelist
[[Preconditions:] [`size` > minimum_stacksize(), `size` < maximum_stacksize() when ! is_stack_unbound().]]
[[Effects:] [Creates an context which will execute `fn`. If `do_unwind` is true the destructor of `*this` unwinds
the stack before destructing it. If `do_return` is `false` the application exits with return code `0`, otherwise
the execution control is transfered back to the invoker (`resume()` returns).]]
[[Throws:] [__invalid_argument__ if precondition is not fulfilled.]]
]

[heading `template< typename Fn, typename Allocator > context( Fn fn, std::size_t size, flag_unwind_t do_unwind, flag_return_t do_return, Allocator const& alloc)`]
[variablelist
[[Effects:] [Creates an context which will execute `fn`. If `do_unwind` is true the destructor of `*this` unwinds
the stack before destructing it. If `do_return` is `false` the application exits with return code `0`, otherwise
the execution control is transfered back to the invoker (`resume()` returns).]]
]

[heading `template< typename Fn > context( Fn fn, std::size_t size, flag_unwind_t do_unwind, context & nxt)`]
[variablelist
[[Preconditions:] [`size` > minimum_stacksize(), `size` < maximum_stacksize() when ! is_stack_unbound(), `nxt` is not a __not_a_context__.]]
[[Effects:] [Creates an context which will execute `fn`. If `do_unwind` is true the destructor of `*this` unwinds
the stack before destructing it. The execution control is transfered to `nxt` if `fn` returns (`nxt` is linked).]]
[[Throws:] [__invalid_argument__ if precondition is not fulfilled.]]
]

[heading `template< typename Fn, typename Allocator > context( Fn fn, std::size_t size, flag_unwind_t do_unwind, context & nxt, Allocatorconst& alloc)`]
[variablelist
[[Preconditions:] [`nxt` is not a __not_a_context__.]]
[[Effects:] [Creates an context which will execute `fn`. If `do_unwind` is true the destructor of `*this` unwinds
the stack before destructing it. The execution control is transfered to `nxt` if `fn` returns (`nxt` is linked).]]
]

[heading `template< typename Fn, typename A0,... > context( Fn fn, A0 a0,..., std::size_t size, flag_unwind_t do_unwind, flag_return_t do_return)`]
[variablelist
[[Preconditions:] [`size` > minimum_stacksize(), `size` < maximum_stacksize() when ! is_stack_unbound().]]
[[Effects:] [Creates an context which will execute `fn` (arguments `A0`,... are bound to `fn`). If `do_unwind` is true the destructor of `*this` unwinds
the stack before destructing it. If `do_return` is `false` the application exits with return code `0`, otherwise
the execution control is transfered back to the invoker (`resume()` returns).]]
[[Throws:] [__invalid_argument__ if precondition is not fulfilled.]]
]

[heading `template< typename Fn, typename Allocator, typename A0,... > context( Fn fn, A0 a0,..., std::size_t size, flag_unwind_t do_unwind, flag_return_t do_return, Allocator const& alloc)`]
[variablelist
[[Preconditions:] [`size` > minimum_stacksize(), `size` < maximum_stacksize() when ! is_stack_unbound().]]
[[Effects:] [Creates an context which will execute `fn` (arguments `A0`,... are bound to `fn`). If `do_unwind` is true the destructor of `*this` unwinds
the stack before destructing it. If `do_return` is `false` the application exits with return code `0`, otherwise
the execution control is transfered back to the invoker (`resume()` returns).]]
[[Throws:] [__invalid_argument__ if precondition is not fulfilled.]]
]

[heading `template< typename Fn, typename A0,... > context( Fn fn, A0 a0,..., std::size_t size, flag_unwind_t do_unwind, context & nxt)`]
[variablelist
[[Preconditions:] [`size` > minimum_stacksize(), `size` < maximum_stacksize() when ! is_stack_unbound(), `nxt` is not a __not_a_context__.]]
[[Effects:] [Creates an context which will execute `fn` (arguments`A0`,... are bound to `fn`). If `do_unwind` is true the destructor of `*this` unwinds
the stack before destructing it. The execution control is transfered to `nxt` if `fn` returns (`nxt` is linked).]]
[[Throws:] [__invalid_argument__ if precondition is not fulfilled.]]
]

[heading `template< typename Fn, typename Allocator, typename A0,... > context( Fn fn, A0 a0,..., std::size_t size, flag_unwind_t do_unwind, context & nxt, Allocator const& alloc)`]
[variablelist
[[Preconditions:] [`nxt` is not a __not_a_context__.]]
[[Effects:] [Creates an context which will execute `fn` (arguments`A0`,... are bound to `fn`). If `do_unwind` is true the destructor of `*this` unwinds
the stack before destructing it. The execution control is transfered to `nxt` if `fn` returns (`nxt` is linked).]]
]

[heading `~context()`]
[variablelist
[[Effects:] [Destroyes the instance and deallocates the stack. Unwinds the stack if it was specified in the
constructor of `*this`.]]
[[Throws:] [Nothing.]]
]

[heading `context( context && other)`]
[variablelist
[[Effects:] [Moves the internal data of `other` to `*this`.
`other` becomes __not_a_context__.]]
[[Throws:] [Nothing.]]
]

[heading `context & operator=( context && other)`]
[variablelist
[[Effects:] [Destroyes the internal data of `*this` and moves the
internal data of `other` to `*this`. `other` becomes __not_a_context__.]]
[[Throws:] [Nothing.]]
]

[heading `operator unspecified-bool-type() const`]
[variablelist
[[Returns:] [If `*this` refers to __not_a_context__, the function returns
false. Otherwise true.]]
[[Throws:] [Nothing.]]
]

[heading `bool operator!() const`]
[variablelist
[[Returns:] [If `*this` refers not to __not_a_context__, the function returns
true. Otherwise false.]]
[[Throws:] [Nothing.]]
]

[heading `void swap( context & other)`]
[variablelist
[[Effects:] [Swaps the internal data from `*this` with the values
of `other`.]]
[[Throws:] [Nothing.]]
]

[heading `bool is_complete() const`]
[variablelist
[[Preconditions:] [`*this` is not a __not_a_context__.]]
[[Effects:] [Returns `true` if context-function of `*this` has returned.]]
[[Throws:] [Nothing.]]
]

[heading `bool is_running() const`]
[variablelist
[[Preconditions:] [`*this` is not a __not_a_context__.]]
[[Effects:] [Returns `true` if `*this` is the currently active context.]]
[[Throws:] [Nothing.]]
]

[heading `void * start()`]
[variablelist
[[Preconditions:] [`*this` is not a __not_a_context__, `! is_complete()` and
`! is_running()`.]]
[[Effects:] [`start()` enters the __context_fn__ `fn` with wich the context was
constructed. When the function returns, the context was either left via
`suspend()` or the __context_fn__ returned.]]
[[Returns:] [A void pointer passed to `suspend()` is returned if the context
was left with `suspend()`.]]
[[Throws:] [Nothing.]]
]

[heading `void * resume( void * vp = 0)`]
[variablelist
[[Preconditions:] [`*this` is not a __not_a_context__, `! is_complete()` and
`! is_running()`, `start()` was called before.]]
[[Effects:] [If `*this` was suspended (by `suspend()`) the execution control
is transfered back resuming `*this` (means `suspend() returns). The argument
`vp` will be returned by `suspend()`.]]
[[Returns:] [A void pointer passed to `suspend()` is returned if the context
was left with `suspend()`.]]
[[Throws:] [Nothing.]]
]

[heading `void * suspend( void * vp = 0)`]
[variablelist
[[Preconditions:] [`*this` is not a __not_a_context__, `! is_complete()` and
`is_running()`.]]
[[Effects:] [Suspends `*this` by transfering the executiin control back to
the code which has invoked `resume()` befor. The argument `vp` will be
returned by `resume()`.]]
[[Throws:] [Nothing.]]
]

[heading `void unwind_stack()`]
[variablelist
[[Preconditions:] [`*this` is not a __not_a_context__, `! is_complete()` and `! is_running()`.]]
[[Effects:] [Does unwinding all objects allocated by the stack owned by `*this`.]]
[[Throws:] [Nothing.]]
[[Postconditions:] [`*this` is not a __not_a_context__ and `is_complete()`.]]
]

[heading Non-member function `swap()`]

    void swap( context & l, context & r);

[variablelist
[[Effects:] [Swaps content of `l` with `r`.]]
]

[endsect]

[endsect]
